### 悲观锁 && 乐观锁

悲观锁和乐观锁是广义上的概念，体现了线程并发同步的不同角度，不是指具体类型的锁。

* 悲观锁：对同一数据的并发操作，悲观锁认为自身在修改数据的时候一定有其它线程来修改数据，因此在获取数据的时候会先加锁，确保其它线程无法修改。Java中synchronized关键字和Lock都是悲观锁的体现，就是利用各种锁。

* 乐观锁：对同一数据的并发操作，乐观锁认为自身在修改数据的时候不会有其它线程修改数据，所以不会加锁，只是在更新数据的时候会去判断之前有没有线程更新过该数据，如果数据没有被更新，将自己修改的值写入；如果已被其它线程更新，则根据不同的实现方式进行不同的操作（例如报错或自动重试）。乐观锁在Java中通过无锁编程来实现，最常采用的是CAS算法，Java原子类的自增操作就是通过CAS自旋实现的。

### 使用场景

* 悲观锁：适合写操作多的场景，先加锁保证写操作时数据正确。

* 乐观锁：适合读操作多的场景，不加锁能够让读操作的性能大幅提升。

### CAS Compare And Swap 

多线程同步机制的原子指令，CAS是无锁算法，属于自旋锁；在无锁（线程非阻塞）的情况下实现多线程之间变量的同步。Java中提供的原子类都实现了CAS。

#### 参数

- 内存地址V

- 旧的预期值A

- 即将更新的目标值B

    CAS指令执行时，当且仅当内存地址V的值和旧的预期值A相等，此时将内存地址V更新为目标值B，否则，什么也不做。
    
#### 核心

- 保证了原子性

- 内存屏障

#### 缺点

- 循环开销大：CAS不成功，会一直进行循环尝试，给CPU带来比较大的开销。

- 只能保证一个变量的原子操作，无法保证多个变量的原子操作：从JDK1.5开始，提供了AtomicReference，保证了引用对象的原子性，可以把多个变量放在一个对象中。

- 存在ABA问题：CAS操作时，检查内存值是否发生变化，没有变化才会更新内存值。但是如果内存值原来是A，后变成了B，最后又变为了A，CAS检查时值没有发生变化，实际是变化了的。ABA问题解决的思路是前面加上版本号，
JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet里面，比较当前引用和预期引用及当前版本和预期版本，如果两者都相等则以原子操作将当前引用值和标记值设置为新的值。